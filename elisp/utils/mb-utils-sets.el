(provide 'mb-utils-sets)

(defstruct
  (interval
    (:constructor interval-oo (l r &aux (open-left t) (open-right t)))
    (:constructor interval-oc (l r &aux (open-left t) (open-right nil)))
    (:constructor interval-co (l r &aux (open-left nil) (open-right t)))
    (:constructor interval-cc (l r &aux (open-left nil) (open-right nil))))
  l r (open-left t) (open-right t))

(defun open-left-p (intv) (interval-open-left intv))
(defun open-right-p (intv) (interval-open-right intv))
(defun closed-left-p (intv) (not (open-left-p intv)))
(defun closed-right-p (intv) (not (open-right-p intv)))
;(interval-l (make-interval :l 1 :r 2))
;(open-left-p (interval-oo 1 1))

(defun interval-list (interval)
  (list (interval-l interval) (interval-r interval)))
;;(interval-list (interval-oo 1 2))

(cl-defun 1-sphere (radius &optional (center 0))
  (interval-cc (- center radius) (+ center radius)))
;;(within 1 (1-sphere 1))

(cl-defun within (x interval &key (test #'<))
  "Returns T if X is within INTERVAL. This could be made a macro
later."
  (cl-labels ((= (a b) (and (not (funcall test a b)) 
			 (not (funcall test b a)))))
    (not (or (funcall test x (interval-l interval))
	     (funcall test (interval-r interval) x)
	     (and (open-left-p interval) (= x (interval-l interval)))
	     (and (open-right-p interval) (= x (interval-r interval)))))))
;;(contained 1 (interval-oo 1 2))

;;;; closed intervals of integers: '(a b) is [a b] of integers
(defun i-disjoint-n (n interval) 
  (not (or (i-within n interval) (i-touch n interval))))
(defun i-touch-n (n interval) 
  (or (= n (first interval)) (= n (second interval))))
(defun i-within-n (n interval) 
  (error "obsolete, use contains instead"))

(defun i-contains (interval x) 
  (if (listp x)
    (and (<= (first interval) (first x))
	 (>= (second interval) (second x)))
    (-< (first interval) x (second interval))))
(defun i-within (interval1 interval2) 
  (i-contains interval2 interval1))
(defun i-within-strictly (interval1 interval2) 
  (and (i-within interval1 interval2)
       (nequal interval2 interval2)))
;;(i-contains '(0 3) '(1 2))
(defun i-disjoint (interval1 interval2) 
  (or (< (second interval1) (first interval2))
      (< (second interval2) (first interval1))))
;;(i-disjoint '(0 2) '(3 5))
(defun i-touch (interval1 interval2)
  (let ((a (first interval1)) (b (second interval1))
	(c (first interval2)) (d (second interval2)))
    (if (< a c) (= b c) (= a d))))
;;(i-touch '(0 2) '(-1 0))
(defun i-overlap (interval1 interval2)
  (let ((a (first interval1)) (b (second interval1))
	(c (first interval2)) (d (second interval2)))
    (or (-< a c b d) (-< c a d b))))
;;(i-overlap '(0 2) '(1 3))

(defun i-intersection (interval1 interval2)
  (and (not (i-disjoint interval1 interval2))
       (subseq (sort (append interval1 interval2) #'<) 1 3)))
;;(i-intersection '(4 4) '(1 3))
