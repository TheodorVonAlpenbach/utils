(in-package :mb-grid)

;;; A tiny implementation of matrix as a list of row vectors
;;; This is hairy. Should use real matrices instead, me thinks (MB).
;;; These methods should by no means be exported.
(defun vec (n &optional (init 0)) (make-list n :initial-element init))
(defun vec+ (vec &rest vecs) (apply #'map (type-of vec) #'+ vec vecs))
(defun vec- (vec &rest vecs) (apply #'mapcar #'- vec vecs))
(defun vec-copies (vec n) (loop repeat n collect (copy-list vec)))
(defun dot-product (vec1 vec2) (reduce #'+ (map (type-of vec1) #'safe-* vec1 vec2)))
;;(dot-product '(1 1) '(2 1))

(defun mat (n &optional (m n) (init 0)) (loop for i below n collect (vec m init)))
(defun mat+ (mat &rest mats) (apply #'mapcar #'vec+ mat mats))
(defun diagmat (vec) (let ((res (mat (length vec))))
		       (loop for row in res
			     for x in vec
			     for i from 0
			     do (setf (nth i row) x))
		       res))
;;; The utils actually used are VEC-, VEC-COPIES, DOT-PRODUCT, MAT+, DIAGMAT.

(defun grid-axes-dimensions (axes) (mapcar #'length axes))
(defun grid-dimensions (grid) (grid-axes-dimensions (grid-axes grid)))
;;(grid-dimensions *test-grid*)

(defun generate-index-points (&optional (dimensions '(4 3 2)))
  (labels ((gip (dimensions indexes)
	     (loop for i below (first dimensions)
		   if (rest dimensions) append (gip (rest dimensions) (cons i indexes))
		   else collect (reverse (cons i indexes)))))
    (gip dimensions ())))
;;(generate-index-points '(3 2))

(defun grid-index-points (grid) (generate-index-points (grid-dimensions grid)))
;;(grid-index-points *test-grid*)

(defun index-point->grid-point (index-point grid-axes)
  (mapcar #'aref grid-axes index-point))
;;(index-point->grid-point '(1 1) (list #(0 2 4) (vector pi (exp 1))))

(defun index-point->grid-value (index-point grid-data)
  (apply #'aref grid-data index-point))
;;(index-point->grid-value '(1 0) (grid-data *test-grid*))

;;; this will become obsolete
(defun populate-array (fn grid-axes)
  "GRID-AXES should contain the value axess for each dimension.
Note that the order here is outer dimension first, just like for an
ARRAY object."
  (let ((array (make-array (grid-axes-dimensions grid-axes))))
    (loop for index-point in (generate-index-points (grid-axes-dimensions grid-axes))
	  do (setf (apply #'aref array index-point)
		   (funcall fn (index-point->grid-point index-point grid-axes))))
    array))
;;(populate-array #'(lambda (p) (reduce #'+ p)) (list #(0 2 4) #(1 3)))
;;(generate-array '(2 2)) ==> #2A((0 1) (2 3))

(defun subscripts-rev (dimensions row-major-index)
  "Helper function for SUBSCRIPTS"
  (loop for n = row-major-index then (/ (- n m) d)
	for d in (reverse dimensions)
        for m = (mod n d)
	collect m))

(defun subscripts (dimensions row-major-index)
  "Converts ROW-MAJOR-INDEX corresponding to DIMENSIONS to subscripts."
  (nreverse (subscripts-rev (reverse dimensions) row-major-index)))
;;(mapcar (bind #'subscripts '(10 10 10) 1) (0-n 1000))

(defun array-subscripts (array row-major-index)
  "Converts ROW-MAJOR-INDEX corresponding to ARRAY's dimensions to subscripts.
That is x == (array-row-major-index arr (array-subscripts arr x))."
   (subscripts (array-dimensions array) row-major-index))

(defun make-test-grid ()
  (span-grid (lambda (p) (sqrt (reduce #'+ p))) '(#(0 1 2) #(5 10))))
(defparameter *test-grid* (make-test-grid))
;;(setf *test-grid* (make-test-grid))

(defun closest-index-edge (x axis)
  "Returns the pair \(N d\), where N is the index of the closest element to X in AXIS,
and d is the offset to the index of the second closest element to X in
AXIS. Hence d is either -1 or 1. The function is of order O(logN), and
assumes that X is a number and that AXIS is a vector of sorted
numbers."
  (destructuring-bind (imin imax) (sequence-index-boundary axis)
    (cond ((< x (aref axis 0))                      ;left of axis axes
	   (list imin 1))      
	  ((> x (aref axis (1- (length axis))))     ;right of axis axes
	   (list imax -1))
	  ;; Else, we search for best index in O(log(N)) time
	  (t (loop for (a b) = (list imin imax) then (if (< (aref axis i) x) (list i b) (list a i))
		   for i = (floor (+ b a) 2)
		   if (= i a) return (if (< (- x (aref axis i))
					    (- (aref axis (1+ i)) x))
				       (list i 1)
				       (list (1+ i) -1)))))))
;;(mapcar (bind #'closest-index-edge #(0 1 2 3)) '(-1 0 0.5 1 1.5 2.5 3 4))

(defun closest-index-edges (point axes)
  "Coordinate order in each egde: innermost dimension first"
  (mapcar #'(lambda (x axis) (closest-index-edge x axis)) point axes))
;;(closest-index-edges '(0 10) (grid-axes *test-grid*))

(defun closest-index-points (index-edges)
  "Coordinate order in each index point: innermost dimension first"
  (let ((index-point (mapcar #'first index-edges))
	(offset-mat (diagmat (mapcar #'second index-edges))))
    (cons index-point
	  (mat+ (vec-copies index-point (length index-point)) offset-mat))))
;;(closest-index-points (closest-index-edges '(0 5) (grid-axes *test-grid*)))

(defvar *rao-verbose* nil)
;;(setf *rao-verbose* nil)

(defun interpolate (point reference-points reference-values)
  "Solves Xa = f, where X = (x1, x2, ..)^T is the result of
`grid-closest-base-vectors', f = (f1 - f0, f2 - f0, ..), where f0 is
F(point), f1 = F(point + x1), f2 = (point + x2), .."
  (let* ((p0 (first reference-points))
	 (p (rest reference-points))
	 (f0 (first reference-values))
	 (f (rest reference-values))
	 (V (mapcar (bind #'vec- p0) p))
	 (fd (mapcar (bind #'- f0) f))
	 (a (matrix-column (matrix-product (invert-matrix (tree->array V))
					   (tree->array (mapcar #'list fd)))))
	 (b (- f0 (dot-product a p0)))
	 (F^ (+ (dot-product a point) b)))
    (if *rao-verbose*
      (values F^ (list :p0 p0 :p p :V V :f0 f0 :f f :fd fd :a a :b b))
      F^)))
;;(grid-interpolate '(2 2 0) *test-grid*)

(defun grid-interpolate (point grid)
  "Solves Xa = f, where X = (x1, x2, ..)^T is the result of
`grid-closest-base-vectors', f = (f1 - f0, f2 - f0, ..), where f0 is
F(point), f1 = F(point + x1), f2 = (point + x2), .."
  (let* ((index-edges (closest-index-edges point (grid-axes grid)))
	 (index-points (closest-index-points index-edges))
	 (points (mapcar (bind #'index-point->grid-point (grid-axes grid)) index-points))
	 (values (mapcar (bind #'index-point->grid-value (grid-data grid)) index-points)))
    (when *rao-verbose* (print (list point index-edges index-points points values)))
    (interpolate point points values)))
;;(grid-interpolate '(1 10) *test-grid*)

(defun test-grid-interpolate (grid)
  (loop for ip in (grid-index-points grid)
	for gp = (index-point->grid-point ip (grid-axes grid))
	for iv = (grid-interpolate gp grid)
	for gv = (index-point->grid-value ip (grid-data grid))
	collect (abs (- iv gv))))
;;(reduce #'+ (test-grid-interpolate *test-grid*))

(defun reshape-grid (grid new-axes)
  "Axes dimension order: outer dimension first"
  (span-grid (lambda (p) (grid-interpolate p grid)) new-axes))
;;(reshape-grid *test-grid* '(#(0 .5 1) #(5 10)))
