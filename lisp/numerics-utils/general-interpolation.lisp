(in-package :mb-grid)

;;; some shortcuts
(defun m- (&rest args) (apply #'matrix-difference args))
(defun m+ (&rest args) (apply #'map-array #'+ args))
(defun m* (&rest args) (reduce #'matrix-product args :from-end t))
(defun m-1 (&rest args) (apply #'matrix-inversion args))
(defun mT (&rest args) (apply #'matrix-transpose args))
;;(m* #2a((1 2) (1 2)) #2a((1 2) (1 2)) #2a((1 2) (1 2)))

(defun independent-p (vectors) (= (rank vectors) (length vectors)))

(defun select-basis (x points &optional values)
  "Please revise this. VALUES should not be needed, really"
  (assert (= (length points) (length values)) () "points and values do not have the same length")
  (let* ((x0 (minimum points :key (bind #'matrix-distance x)))
	 (objs (loop for x in points
		     for y in values
		     collect (list x (m- x x0) y)))
	 (r (rank (mapcar #'second objs)))
	 (sorted-objs (sort objs #'< :key #'(lambda (obj) (matrix-distance (first obj) x))))
	 (independent-objs (loop with res = ()
				 for obj in sorted-objs
				 for (x v y) = obj
				 while (< (length res) r)
				 if (independent-p (cons v (mapcar #'second res)))
				 do (push obj res)
				 finally (return (reverse res)))))
    (list :x0 x0
	  :y0 (third (first sorted-objs))
	  :x (mapcar #'first independent-objs)
	  :y (mapcar #'third independent-objs)
	  :v (mapcar #'second independent-objs))))
;;(select-basis #(0 1) '(#(4 0) #(0 4)) (make-list 2))

(defun solve-linear-equation (X y)
  "Solves y = Xa + b, and returns the solution as the list (a b).
For some positive integer N, X must be an (N+1)xN matrix and y must be
an (N+1)x1 (column) matrix. The returned solution is the list (a b),
where a is an Nx1 (column) matrix and b is a scalar."
  (let* ((V (map-rows (bind #'m- (matrix-row X 0)) X :start 1))
	 (z (map-rows (bind #'m- (matrix-row y 0)) y :start 1))
	 (a (m* (m-1 V) z)))
    ;; b = y0 = a^T * x0
    (list (matrix-column a 0)
	  (aref (m- (submatrix y :rows 0) (m* (submatrix x :rows 0) a)) 0 0))))
;;(unintern 'solve-linear-equation)

;;;; The rest of the module is about general N-dimensional interpolation
;;;; The inputs is currently in lists. It should be changed into matrices and vectors
(defun projection-matrix (vectors)
  "Calculates the project matrix generated by VECTORS,
by calculating P = A (A^T A)^-1 A^T, where A is matrix with VECTORS as
columns."
  (let* ((a (columns->matrix vectors))
	 (aT (mT a)))
    (m* a (m-1 (m* aT a)) aT)))
;;(projection-matrix '(#(2 2)))

(defun project-onto-subspace (x vectors)
  "Project point X, a vector, onto the subspace spanned by VECTORS,
by calculating P*X, where P is the PROJECTION-MATRIX generated by by VECTORS"
  (array-column (m* (projection-matrix vectors) (column->matrix x))))
;;(project-onto-subspace #(2 0) '(#(2 2)))

(defun project-onto-simplex (x simplex)
  "Same as project-onto-subspace, but with subspace spanned by points rather than vectors.
This also allows for translation, i.e. null space (origo)
is not necessarily contained in the subspace."
  (let ((o (first simplex)))
    (m+ o (project-onto-subspace (m- x o) (mapcar (bind #'m- o) (rest simplex))))))
;;(project-onto-simplex #(2 0) '(#(1 0) #(2 1)))

;;; Simpex stuff. SIMPLEX is a list of points. The main target for now
;;; is to decide if a point is within a simplex. Need to compute
;;; determinant, and then I need some deep linear algebra functions.
(defun faculty (n &optional (m 1))
  "Returns N!"
  (loop for i from m to n
	for res = m then (* res i)
	finally return res))
;;(mapcar #'faculty (a-b -1 5))

(defun n-parallelepiped-volume (points)
  "Note that the volume is signed"
  (determinant (mapcar (bind #'m- (first points)) (rest points))))
;;(n-parallelepiped-volume (list #(0 0 0) #(4 0 0) #(0 4 0) #(0 0 2)))

(defun simplex-volume (simplex)
  (/ (n-parallelepiped-volume simplex) (faculty (1- (length simplex)))))
;;(simplex-volume (list #(0 0 0) #(4 0 0) #(0 4 0) #(0 0 2)))

(defmethod project-on-euclidian-subspace ((x cons))
  "Projects list of N vectors X on a Euclidian subspace such that the rank of the vectors are preserved.
If no subspace is found, nil is returned. Otherwise it returns a pair
of VALUES, consisting of the projected vectors are returned together
with the index of the column that was removed as a consequence of the
successful projection.

TODO: Example should be provided. 
TODO: Array? Shouldn't it be N-1 vectors?"
  (loop with n = (length x)
	for i from (1- n) downto 0
	for vsp = (loop for v in x collect (remove-nth i v))
	if (= (rank vsp) n) return (values vsp i)))
;;(project-on-euclidian-subspace '(#(1 0 0) #(2 0 1)))

(defun above-face-p (x face)
  "Returns true iff projection of X onto the space spanned by FACE, is
within the simplex FACE"
  (multiple-value-bind (vs i)
      (project-on-euclidian-subspace face)
    (within-simplex-p
     (remove-nth i (project-onto-simplex x face)) vs)))
;;(above-face-p #(20 0) '(#(1 0 0) #(2 0 1)))

(defun simplex-facets (simplex)
  "This is in fact a util. Rename and move to mb-utils?"
  (loop for i below (length simplex)
	collect (remove-nth i simplex)))
;;(simplex-facets '(0 1 2 3))

(defun within-simplex-p (x simplex &optional strictly-p)
  "See https://en.wikipedia.org/wiki/Simplex"
  (let ((sngs (loop for i below (length simplex)
		    ;; info: if SGN is zero, then X is on the current /facet/
		    ;; if all SNGs are zero, then X is a vertice of SIMPLEX
		    for sgn = (signum (simplex-volume (replace-nth i x simplex)))
		    if (or (not (zerop sgn)) strictly-p)
		    collect sgn)))
    (apply #'= sngs)))
;;(within-simplex-p #(3/2 1/2) '(#(1 0) #(2 1)) nil)

;;(within-simplex-p #(1 0) '(#(0 0) #(4 0) #(0 4)) nil)

(defun select-simplex-basis (x points)
  (let* ((basis (select-basis x points (make-list (length points))))
	 (simplex (cons (getf basis :x0) (getf basis :x))))
    (if (within-simplex-p x simplex)
      simplex
      (loop for facet in (simplex-facets simplex)
	    if (above-face-p x facet) return facet))))
;;(select-simplex-basis #(1 -1) '(#(4 0) #(0 0) #(0 4)))

(defun interpolate-scattered-fn (x points values &optional with-extrapolation-p)
  (let* ((o (if with-extrapolation-p
	      (select-basis x points values)
	      (select-simplex-basis x points values)))
	 (y (column->matrix (cons (getf o :y0) (getf o :y))))
	 (X (rows->matrix  (cons (getf o :x0) (getf o :x)))))
    (destructuring-bind (a b) (solve-linear-equation X y)
      (lambda (x) (+ (vector-inner-product a x) b)))))

(defun interpolate-scattered (x points values)
  (let ((fn (interpolate-scattered-fn x points values)))
    (values (funcall fn x) fn)))

(defun interpolate-scattered-avg (x points values)
  "Q&D implementation of general interpolation: Simply return the
average of VALUES weighted by the square of the distances of
corresponding POINTS to X"
  (let ((d2s (mapcar #'numerics-utils::vector-length-squared
	       (mapcar (bind #'m- x) points))))
    (aif (position-if #'zerop d2s)
      (elt values it)
      (average values :weights (mapcar #'(lambda (x) (/ 1 x)) d2s)))))
;;(interpolate-scattered-avg #(0.4 0) '(#(0 0) #(0.5 0) #(0 1) #(1 0) #(1 1)) '(0 0.5 1 2 3))
;;(interpolate-scattered-avg #(0.44 0) '(#(0 0) #(0.5 0) #(0 1)) '(0 0.5 2))
