(in-package :timeseries)

(defun same-direction-p (a b c key)
  (destructuring-bind (a b c)
      (mapcar key (list a b c))
    (or (<= a b c) (>= a b c))))
;;(same-direction-p 0 1 0 #'identity)

(defun car-same-direction-p (a b c key)
  (case (length b)
    (0 (and a (same-direction-p (first a) (second a) (third a) key)))
    (1 (and a b c (same-direction-p (car a) (car b) (car c) key)))
    (2 (and b c (same-direction-p (car b) (second b) (car c) key)))
    (t (warn "Unexpected length of second argument: B = ~a" b))))
;;(car-same-direction-p '((0 0) (0 1) (0 2)) '() '((0 2)) #'second)
;;(untrace same-direction-p)

(defun distance (x y key) (abs (- (funcall key x) (funcall key y))))
;; (distance '(0 2) '(0 3/4) #'second)

(defun dist-b->c-greater-than-dist-a->b (a b c key)
  "Given that (same-direction-p a b c) is nil, return |a-b|<|b-c|."
  (destructuring-bind (a b c) (mapcar key (list a b c))
    (minusp (* (- a b) (- a c)))))
;;(dist-b->c-greater-than-dist-a->b '(0 0) '(0 1) '(0 -2) #'second)

(defun turning-points (ts threshold &key (key #'identity))
  (when (minusp threshold)
    (error "THRESHOLD cannot be negative"))
  (unless (listp ts)
    (error "Timeseries must be a list"))
  (if (null ts)
    (warn "Timeseries is empty")
    (let (res register)
      (print (length ts))
      (loop while (and (> (length ts) 2) (car-same-direction-p ts nil nil key))
	    do (pop-nth ts 1))
      (if (= (length ts) 2)
	ts
	(destructuring-bind (a b c) (pop-list ts 3)
	  (loop while ts
		do (print (list :res res :abc (list a b c) :ts ts))
		do (if (same-direction-p a b c key)
		     (setf b c  c (pop ts))
		     (if (>= (distance a b key) threshold)
		       (progn (push a res)
			      (setf a b  b c  c (pop ts)))
		       (if (dist-b->c-greater-than-dist-a->b a b c key)
			 (setf a c  b (pop ts)  c (pop ts))
			 (setf c (pop ts))))))
	  (if (null c)
	    (push* res a b)
	    (if (or (same-direction-p a b c key)
		    (< (distance a b key) threshold))
	      (if (dist-b->c-greater-than-dist-a->b a b c key)
		(push* res a c)
		(push* res c))
	      (push* res a b c)))
	  (nreverse res))))))
;;(turning-points '((0 0) (0 1) (0 2) (0 3) (0 2) (0 1) (0 2) (0 1)) 3/2 :key #'second)
;;(turning-points '(0 1 2 3 2 1 2 1) 3/2)
